#### 1， 索引的作用？她的优点缺点是什么？

索引就一种特殊的查询表，数据库的搜索引擎可以利用它加速对数据的检索。索引很类似与现实生活中书的目录，不需要查询整本书内容就可以找到想要的数据。缺点是它减慢了数据录入的速度，同时也增加了数据库的尺寸大小。

#### 2，介绍存储过程基本概念和 她的优缺点？

存储过程是一个预编译的SQL语句，他的优点是允许模块化的设计，也就是说只需创建一次，在该程序中就可以调用多次。例如某次操作需要执行多次SQL，就可以把这个SQL做一个存储过程，因为存储过程是预编译的，所以使用存储过程比单纯SQL语句执行要快。缺点是可移植性差，交互性差。

#### 3，使用索引有哪些需要注意的地方？

- 创建索引的的字段尽量小，最好是数值，比如整形int等；
- 对于频繁修改的字段，尽量不要创建索引，维护索引的成本很高，而且更容易产生索引碎片；
- 定期的索引维护，如索引碎片的修复等；
- 不要建立或维护不必要的重复索引，会增加修改数据（新增、修改、删除数据）的成本；
- 使用唯一性高的字段创建索引，切不可在性别这样的低唯一性的字段上创建索引；
- 在SQL语句中，尽量不要在Where条件中使用函数、运算符或表达式计算，会造成索引无法正常使用；
- 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描；
- 应尽量避免在 where 子句中使用!=或<>操作符，否则将导致引擎放弃使用索引而进行全表扫描；

#### 4，索引碎片是如何产生的？有什么危害？又该如何处理？

索引在使用一段时间后（主要是新增、修改、删除数据，如果该页已经存储满了，就要进行页的拆分，频繁的拆分，会产生较多的索引碎片）会产生索引碎片。

索引碎片会严重印象数据的查询效率，如果碎片太多，索引可能不会被使用。

碎片的处理方式主要有两种：

**第一种是预防**：设置页的填充因子

意思就是在页上设置一段空白区域，在新增数据的时候，可以使用这段空白区域，可以一定的避免页的拆分，从而减少索引碎片的产生。

填充因子就是用来描述这种页中填充数据的一个比例，一般默认是100%填充的。如果我们修改填充因子为80%，那么页在存储数据时，就会剩余20%的剩余空间，这样在下次插入的时候就不会拆分页了。 那么是不是我们可以把填充因子设置低一点，留更多的剩余空间，不是很好嘛？当然也不好，填充因子设置的低，会需要分配更多的存储空间，叶子节点的深度会增加，这样是会影响查询效率的，因此，这是要根据实际情况而定的。

那么一般我们是怎么设置填充因子的呢，主要根据表的读写比例而定的。如果读的多，填充因子可以设置高一点，如100%，读写各一半，可以80~90%；修改多可以设置50~70%。

**第二种是索引修复**：定期对索引进行检查、维护，写一段SQL检查索引的碎片比例，如果碎片过多，进行碎片修复或重建，定期执行即可。

#### 5，锁的目的是什么？

主要解决多个用户同时对数据库的并发操作时会带来以下数据不一致的问题：

- 丢失更新，同时修改一条数据
- 读脏，A修改了数据后，B读取后A又取消了修改，B读脏
- 不可重复读，A用户读取数据,随后B用户读取该数据并修改,此时A用户再读取数据时发现前后两次的值不一致
- 还有一种是幻读，这个情况好像不多。

并发控制的主要方法是封锁,锁就是在一段时间内禁止用户做某些操作以避免产生数据不一致

#### 6，锁的粒度有哪些？

- 数据库锁：锁定整个数据库，这通常发生在整个数据库模式改变的时候。
- 表锁：锁定整个表，这包含了与该表相关联的所有数据相关的对象，包括实际的数据行(每一行)以及与该表相关联的所有索引中的键。
- 区段锁：锁定整个区段，因为一个区段由8页组成，所以区段锁定是指锁定控制了区段、控制了该区段内8个数据或索引页以及这8页中的所有数据行。
- 页锁：锁定该页中的所有数据或索引键。
- 行或行标识符：虽然从技术上将，锁是放在行标识符上的，但是本质上，它锁定了整个数据行。

#### 7，什么是事务？什么是锁？

事务就是被绑定在一起作为一个逻辑工作单元的SQL语句分组，如果任何一个语句操作失败那么整个操作就被失败，以后操作就会回滚到操作前状态，或者是上个节点。为了确保要么执行，要么不执行，就可以使用事务。要将所有组语句作为事务考虑，就需要通过ACID测试，即原子性，一致性，隔离性和持久性。
锁是实现事务的关键，锁可以保证事务的完整性和并发性。

#### 8，视图的作用，视图可以更改么？

视图是虚拟的表，与包含数据的表不一样，视图只包含使用时动态检索数据的查询；不包含任何列或数据。使用视图可以简化复杂的sql操作，隐藏具体的细节，保护数据；视图创建后，可以使用与表相同的方式利用它们。

视图的目的在于简化检索，保护数据，并不用于更新。

#### 9，什么是触发器(trigger)? 触发器有什么作用?

触发器是数据库中由一定时间触发的特殊的存储过程，他不是由程序掉用也不是手工启动的。触发器的执行可以由对一个表的insert,delete, update等操作来触发，触发器经常用于加强数据的完整性约束和业务规则等等。

#### 10，SQL里面IN比较快还是EXISTS比较快?

这个题不能一概而论，要根据具体情况来看。IN适合于外表大而内表小的情况；EXISTS适合于外表小而内表大的情况。

如果查询语句使用了not in，那么对内外表都进行全表扫描，没有用到索引；而not exists的子查询依然能用到表上的索引。所以无论哪个表大，用not exists都比not in 要快。参考资料：http://www.cnblogs.com/seasons1987/archive/2013/07/03/3169356.html

#### 11，维护数据库的完整性和一致性，你喜欢用触发器还是自写业务逻辑?为什么?

尽可能使用约束，如check、主键、外键、非空字段等来约束。这样做效率最高，也最方便。其次是使用触发器，这种方法可以保证，无论什么业务系统访问数据库都可以保证数据的完整新和一致性。最后考虑的是自写业务逻辑，但这样做麻烦，编程复杂，效率低下。

#### 12，存储原理

数据库文件存储是以页为存储单元的，一个页是8K（8192Byte），一个页就可以存放N行数据。我们表里的数据都是存放在页上的，这种叫数据页。还有一种页存放索引数据的，叫索引页。

同时，页也是IO读取的最小单元（物理IO上不是按行读取），也是所有权的最小单位。如果一页中包含了表A的一行数据，这页就只能存储表A的行数据了。或是一页中包含了索引B的条目，那这页也仅仅只能存储索引B的条目了。每页中除去存储数据之外，还存储一些页头信息以及行偏移以便SQL Server知道具体每一行在页中的存储位置。

![image](https://images2015.cnblogs.com/blog/151257/201603/151257-20160315222930474-357919205.png)



#### 13，聚集索引

**聚集索引**决定了表数据的物理存储顺序，也就是说表的物理存储是根据聚集索引结构进行顺序存储的，因此一个表只能有一个聚集索引。如下图，就是一个聚集索引的树结构：

- 所有数据都在叶子节点的页上，在叶子节点（数据页）之间有一个链指针，这是B+树的特点；
- 非叶子节点都是索引页，存储的就是聚集索引字段的值；
- 表的物理存储就是依据聚集索引的结构的，一个表只能有一个聚集索引；

![image](https://images2015.cnblogs.com/blog/151257/201603/151257-20160315222932646-1251523558.png)

聚集索引的所有的数据都存储在叶子节点上，数据查询的复杂度都是一样的（树的深度），按照聚集索引列查找数据效率是非常高的。上面说了，聚集索引决定了表的物理存储结构，那如果没有创建聚集索引，会如何呢？——**表内的所有页都无序存放，是一个无序的堆结构**。堆数据的查询就会造成表扫描，性能是非常低的。

**因此聚集索引的的重要性不言而喻，一般来说，大多会对主键建立聚集索引，大多数普通情况这么做也可以。但实际应用应该尊从一个原则就是“频繁使用的、排序的字段上创建聚集索引”**

#### 14，非聚集索引

除了聚集索引以外的其他索引，都称之为非聚集索引，非聚集索引一般都是为了优化特定的查询效率而创建的。非聚集索引也是B树（B+树和B-树）的结构，与非聚集索引的存储结构唯一不一样的，就是非聚集索引中不存储真正的数据行，因为在聚集索引中已经存放了所有数据，非聚集索引只包含一个指向数据行的指针即可。

![13102058-b7c8255002de4ee4beb89c2dc0c0526c](https://images2015.cnblogs.com/blog/151257/201603/151257-20160315222933818-209915038.png)

- 非聚集索引的创建会单独创建索引文件来存储索引结构，会占用一定存储空间，就是用空间换时间；
- 非聚集索引的目的很单纯：提高特定条件的查询效率，一个表有可能根据多种查询需求创建多个非聚集索引；

![img](https://images.cnblogs.com/cnblogs_com/changbluesky/WindowsLiveWriter/SQLServer6IndexandTSQLTuning_DD36/image_4.png)

数据查询SQL简单来看，分为两个部分：SELECT**** 和 Where ****，因此索引的创建也是根据这两部分来决定的。根据这两点，有两种主要的索引形式：复合索引和覆盖索引，在实际使用中，根据具体情况可能都会用到，只要能提高查询效率就是好索引。

> **覆盖索引**：就是在索引中包含的数据列（非索引列，SELECT需要的列），这样在使用该索引查询数据时就不会再进行键查找（也叫书签查找）了。
>
> **复合索引**：主要针对Where中有多个条件的情况，索引包含多个数据列。在使用复合索引时，应注意多个索引键的顺序问题，这个是会影响查询效率的，一般的原则是唯一性高的放前面，还有就是SQl语句中Where条件的顺序应该和索引顺序一致。
>
> ![image](https://images2015.cnblogs.com/blog/151257/201603/151257-20160315222935146-1300904522.png)



#### 15，索引碎片

前面说过了，索引在使用一段时间后（主要是新增、修改、删除数据，如果该页已经存储满了，就要进行页的拆分，频繁的拆分，会产生较多的索引碎片）会产生索引碎片，这就造成了索引页在磁盘上存储的不连续。会造成磁盘的访问使用的是随机的i/o，而不是顺序的i/o读取，这样访问索引页会变得更慢。如果碎片过多，数据库是可会能不使用该索引的（她嫌弃你太慢了，数据库会选择一个更优的执行计划）。

**第一种是预防**：设置页的填充因子

意思就是在页上设置一段空白区域，在新增数据的时候，可以使用这段空白区域，可以一定的避免页的拆分，从而减少索引碎片的产生。

填充因子就是用来描述这种页中填充数据的一个比例，一般默认是100%填充的。如果我们修改填充因子为80%，那么页在存储数据时，就会剩余20%的剩余空间，这样在下次插入的时候就不会拆分页了。 那么是不是我们可以把填充因子设置低一点，留更多的剩余空间，不是很好嘛？当然也不好，填充因子设置的低，会需要分配更多的存储空间，叶子节点的深度会增加，这样是会影响查询效率的，因此，这是要根据实际情况而定的。

那么一般我们是怎么设置填充因子的呢，主要根据表的读写比例而定的。如果读的多，填充因子可以设置高一点，如100%，读写各一半，可以80~90%；修改多可以设置50~70%。

**第二种是索引修复**：定期对索引进行检查、维护，写一段SQL检查索引的碎片比例，如果碎片过多，进行碎片修复或重建，定期执行即可。

- 创建索引的的字段尽量小，最好是数值，比如整形int等；
- 对于频繁修改的字段，尽量不要创建索引，维护索引的成本很高，而且更容易产生索引碎片；
- 定期的索引维护，如索引碎片的修复等；
- 不要建立或维护不必要的重复索引，会增加修改数据（新增、修改、删除数据）的成本；
- 使用唯一性高的字段创建索引，切不可在性别这样的低唯一性的字段上创建索引；
- 在SQL语句中，尽量不要在Where条件中使用函数、运算符或表达式计算，会造成索引无法正常使用；
- 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描；
- 应尽量避免在 where 子句中使用!=或<>操作符，否则将导致引擎放弃使用索引而进行全表扫描；

#### 16，事务和锁

![image](https://images2015.cnblogs.com/blog/151257/201603/151257-20160315222937412-1960117523.png)

# MySQL实战笔记

# sql执行原理

#### 1，基本结构

![img](https://static001.geekbang.org/resource/image/0d/d9/0d2070e8f84c4801adbfa03bda1f98d9.png)

**Server 层**包括连接器、查询缓存、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。

**存储引擎层**负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。

通过输入engine=memory, 来指定使用内存引擎创建表，**不同的存储引擎共用一个 Server 层**

#### 2，连接器

连接器负责跟客户端建立连接、获取权限、维持和管理连接。连接命令一般是这么写的：

```
mysql -h$ip -P$port -u$user -p
```

#### 3，查询缓存

查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。

对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样：

```
mysql> select SQL_CACHE * from T where ID=10；
```

4，分析器

5，优化器

6，执行器

# 日志系统

#### 1，redo log（重做日志）和 binlog（归档日志）

粉板和账本配合的整个过程，其实就是 MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再写账本。

InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么这块“粉板”总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。

![img](https://static001.geekbang.org/resource/image/16/a7/16a7950217b3f0f4ed02db5db59562a7.png)

write pos 和 checkpoint 之间的是“粉板”上还空着的部分，可以用来记录新的操作。如果 write pos 追上 checkpoint，表示“粉板”满了，这时候不能再执行新的更新，得停下来先擦掉一些记录，把 checkpoint 推进一下。有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。

**粉板 redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。**

1，redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。

2，redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。

3，redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。

这里我给出这个 update 语句的执行流程图，图中**浅色框**表示是在 InnoDB 内部执行的，**深色框**表示是在执行器中执行的。

![img](https://static001.geekbang.org/resource/image/2e/be/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png)

# 事务隔离

MySQL 原生的 MyISAM 引擎就不支持事务，这也是 MyISAM 被 InnoDB 取代的重要原因之一

#### 1，隔离性和隔离级别

隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）

1，读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。

2，读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。

3，可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。

4，串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

举个例子

```
mysql> create table T(c int) engine=InnoDB;
mysql> insert into T(c) values(1);
```

![img](https://static001.geekbang.org/resource/image/7d/f8/7dea45932a6b722eb069d2264d0066f8.png)

1，若隔离级别是“读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。

2，若隔离级别是“读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。

3，若隔离级别是“可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。

4，若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。

配置的方式是，将启动参数 transaction-isolation 的值设置成 READ-COMMITTED。你可以用 show variables 来查看当前的值。

```

mysql> show variables like 'transaction_isolation';

+-----------------------+----------------+

| Variable_name | Value |

+-----------------------+----------------+

| transaction_isolation | READ-COMMITTED |

+-----------------------+----------------+
```

##### 2，事务隔离的实现

假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。
![img](https://static001.geekbang.org/resource/image/d9/ee/d9c313809e5ac148fc39feff532f0fee.png)

数据库的多版本并发控制（MVCC）

你可以在 information_schema 库的 innodb_trx 这个表中查询长事务，比如下面这个语句，用于查找持续时间超过 60s 的事务。

```
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_
```

根据上面的索引结构说明，我们来讨论一个问题：基于主键索引和普通索引的查询有什么区别？

1，如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；

2，如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。

# 锁

根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类

加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。

1，FTWRL的运用场景

















