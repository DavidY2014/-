#  1，高并发解决方案

- 单体结构：垂直加硬件，横向加服务器，loaderunner
- 独立服务器：文件，应用程序，数据库分别放到不同的服务器上
- 本地缓存&&分布式缓存：增加缓存，效果好，费用低，28原则
- 集群负载：多台服务器共同承载，需要做负载均衡，比如nginx，挂掉了不友好，DNS，就近分发硬件F5，软件LVS
- 读写分离：订阅发布服务器进行数据同步，日志复制
- 分库分表：分库就是把数据库按照业务分成仓储，订单，用户等数据库，而不是全放到一个db中。**跨库查询怎么办**数据拷贝，及时查询
- 反向代理CDN
- NoSql&&Redis:防止超卖，就是redis单线程，只让100个请求进入后台程序，只有100个请求进行数据库操作，区别于传统的多线程，锁导致的数据库奔溃






# 2，MQ

运用场景，购票网站，小米官网抢购，电商秒杀

- 削峰限流：超过一定请求数直接丢弃
- 应用解耦：eg：订单系统不会直接调用库存接口，二十通过mq进行间接调用，一般数据库的连接池数量是有限的，如果过多的请求数过来，没有mq的话会导致db的连接资源不够
- MQ：提供消息订阅发布，流量跟踪，RabbitMQ



# 3， 异常处理

- try catch 上端必须得有，保证程序不能异常死掉
- try catch 下端尽量不要写，防止影响流程
- try catch 如果下端要写的话，不能影响后续流程,比如log可以内部try catch

```c#
 private void button5_Click(object sender, EventArgs e)
        {
            try
            {
                ExceptionTest();
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
        }

        private void ExceptionTest()
        {
            try
            {
                int i = 8;
                int j = 0;
                int value = i / j;
                //此时下面这个异常信息抓不到,被覆盖了
                throw new Exception("除数不为0");
            }
            catch (Exception ex)
            {
                //如果异常信息不throw，异常信息又被内部方法吃掉了，也不合适
                throw;
            }
        }
```

# 4，设计模式

- [ ] ### 创建型设计模式：关注对象的创建


**单例模式**：保证进程中只有一个实例（静态字段在进程中只有一个）

```c#
class Program
{
    //这种创建方法不好，1，提前构造了 2，没有做限制，其他人可能在其他地方new Singleton
    public static Singleton singleton = new Singleton();
    static void Main()
    {
		
    }
}
```

```c#
class Singleton
{
	private static volatile Singleton _singleton = null;
	private static readonly object Singleton_Lock = new object()
	public staic Singleton CreateInstance()
	{
        if(_singleton==null)
        {
            //限制并发
            lock(Singleton_Lock)
            {   
                if(_singleton == null)
                {
                    _singleton = new Singleton();
                }
            }
        }
		return _singleton;
	}
}
```

```c#
for(int i=0;i<5;i++)
{
	Task.Run(()=>{
	//此时会构造五个单例，所以要在构造中加锁进行多线程控制
		Singleton.CreateInstance();
	}).start();
}
```

注意：单例也不能保证线程安全，在多个线程调用单例的方法时，也可能带来线程冲突。

单例的用处：数据库连接池，全局唯一号码生成器

**原型模式**：在单例的基础上升级了一下，把对象从内存层面复制了一下，然后返回。

**工厂方法：**

```c#
class FirstFactory : IFactory
{
    public static Instance1 CreateInstance()
    {
        return new Instance1();
    }
}

class SecondFactory : IFactory
{
    public static Instance2 CreateInstance()
    {
        return new Instance2();
    }
}

class Programe
{
    static void Main()
    {
        IFactory factory1 = new FirstFactory();
        Instance1 _instance1 = factory1.CreateInstance();
        IFactory factory2 = new SecondFactory();
        Instance2 _instance2 = factory2.CreateInstance();
        //后续增加不同的实例无需修改现有的代码
    }
}
```

- [ ] ### 结构型设计模式：关注类与类之间的关系


- 代理模式（包一层）

  vpn，翻墙，火车票代理，代理类无法扩展

```c#
class ProxySubject :ISubject
{
    //包一层
    private ISubject _Subject = new RealSubject();
    public void DoSomething()
    {
        this._Subject.DoSomething();
    }
    private static Dictionary<string,bool> ProxyDic = new Dictionary<string,bool> ();
    public bool GetSomething()
    {
        //增加缓存功能，而不修改原来的业务类
        if(ProxyDic.ContainsKey(key))
        {
            ......
        }
        return this._Subject.GetSomething();
    }
}
```

异常处理，日志记录，缓存可以在不修改原来业务类的情况下通过修改代理类添加

- 适配器模式



- [ ] ### 行为型设计模式：关注对象和行为的分离


- 模板方法模式

  1，功能拆分----->创造父类---->代码重用--->普通方法

  2，每个客户端都有不同的功能，比如利率计算-------->抽象方法------>让子类override

  3，部分客户端一样，部分客户端不一样---------->虚方法------>选择性override

```c#
class AbstractBussiness
{
    public void Process1()
    {   
        //普通方法，可通用
    }
    
    public virtual void Process2()
    { 
        //父类也执行的流程，子类选择性覆写，部分通用
    }
    
    public abstract void Process3()；//子类必须override覆写,子类行为各不同
   
}
```

- 观察者模式

  甩锅

```c#
class Cat
{
    private List<IObserver> _ObserverList = new List<IObserver>();
    public void AddObserver(IObserver observer)
    {
        this._ObserverList.Add(observer);
    }
    public void MiaoObserver()
    {
        foreach(var item in this._ObserverList)
        {
            //Cat不执行其他对象的具体行为，只是收集其他对象，并触发其他对象动作，细节
            //还是其他对象在操作 
            item.Action();
        }
    }
}
```

- 责任链

  避免把业务逻辑全糅合在一起

```c#
//任务审批流程
//项目经理
class PM
{
    public string Name {get;set;}
    public void Audit(ApplyContext context)
    {
        //对申请进行审批 
        if()
        {
            
        }else
        {
            Charge,Audit(context);
        }
    }
}

class Charge
{
     public void Audit(ApplyContext context)
    {
        //对申请进行审批    
        if()
        {
            
        }
        else
        {
             Manager,Audit(context);
        }
    }
}

class Manager
{
     public void Audit(ApplyContext context)
    {
        //对申请进行审批  
        if()
        {
            
        }
        else
        {
             Chief,Audit(context);
        }
    }
}

class Chief
{
     public void Audit(ApplyContext context)
    {
        //对申请进行审批    
    }
}
```



# 5，AOP

pop面向过程编程，oop面向对象，aop是对oop的一种补充,通用功能可以通过aop实现，oop是针对静态对象，aop是针对动态对象， MVC的filter也是运用了aop

实现AOP的方式

- 静态实现：装饰器/代理模式

- 动态实现：Remoting /Castle(Emit)

```c#
//必须继承MarshalByRefObject
class UserProcessor:MarshalByRefObject
{
    public void RegUser(User user)
    {
        //业务
    }
}

class RealProxyAOP
{
    public static void Show()
    {
        User user = new User();
        //正常调用
        UserProcessor processor = new UserProcessor();
        processor.Register(user);
        //AOP调用
        UserProcessor userProcessor = TransparentProxy.Create<UserProcessor>();
       	//按道理应该会直接访问UserProcessor的RegUser方法，实际上是进入MyRealProxy的invoke方法
        userProcessor.RegUser(user);
        
    }
}

class MyRealProxy<T> : RealProxy
{
    private T tTarget;
    public MyRealProxy(T target)
    {
        this.tTraget = target;
    }
    
    public override IMessage Invoke(IMessage msg)
    {
        BeforeProceede(msg);
        
        IMethodCallMessage callMessage = (IMethodCallMessage)msg;
        object returnValue = callMessage.MethodBase.Invoke(this.tTarget,callMessage.Args);
        
        AfterProceede(msg);
        return new ReturnMessage(returnValue,new object[0],0,null,callMessage);
    }
}

static class TransparentProxy
{
    public static T Create<T>()
    {
        T instance = Activator.CreateInstance<T>();
        MyRealProxy<T> realProxy = new MyRealProxy<T>(instance);
        T transparentProxy = (T)realProxy.GetTransparentProxy();
        return transparentProxy;
    }
}
```



```c#
using Castle.DynamicProxy;

class MyInterceptor:IInterceptor
{
	public void Intercept(IInvocation invocation)
    {
        PreProcced(invocation);
        invocation.Proceed();
        PostProceed(invocation);
    }

}

class CastleProxyAOP
{
    static void Show()
    {
        User user = new User();
        ProxyGenerator generator = new ProxyGenerator();
        MyInterceptor interceptor = new MyInterceptor();
        UserProcessor userProcessor = generator.CreateClassProxy<UserProcessor>(interceptor);
        userProcessor.RegUser(user);
    }
}
```



# 6，Unity

1，配置unity容器

```c#
//配置Unity
IUnityContainer container = new UnityContainer();
ExeConfigurationFileMap fileMap = new ExeConfigurationFileMap();
fileMap.ExeConfigFilename = Path.Combine(AppDomain.CurrentDomain.BaseDirectory+"configFiles\\Unity.Config");
ConfigurationManager.OpenMappedExeConfiguration(fileMap,ConfigurationUserLevel.None);
UnityConfigurationSection configSection = (UnityConfigurationSection)configuration.GetSection(UnityConfigurationSection.SectionName);
configSection.Configure(container,"aopContainer");

//使用此容器
IUserProcessor processor = container.Resole<IUserProcessor>();
processor.XXX;
```



# 7，多线程

- 多线程异常处理

```c#
try
{
    List<Task> taskList = new List<Task>();
    for(int i =0;i<1000;i++)
    {
        Task.Run(()=>{
            try
            {
                //通常做法是在多线程委托中try-catch
                if()
                {
                   throw new Exception("异常发生") 
                }
                //多线程抛出的异常只会终结当前线程，不会影响别的线程
                //线程异常被吞了----怎么获取异常
            }
            catch(Exception ex)
            {
                
            }
        });
    }
    Task.WaitAll(taskList.ToArray());
}
catch(AggregateException aex)
{
    foreach(var exceptionItem in aex.InnerExceptions)
    {
        //exceptionItem就是发生异常的线程
    }
}
catch(Exception ex)
{
    //此时可以catch到多线程中发生的异常
}
//通常的做法是在多线程委托内部try-catch，不会waitall
```

- 线程取消

```c#
//Thread.Abort() 终止线程，向当前线程抛一个异常，但是此时OS未必会及时响应,不推荐使用
//cts 有个bool属性叫IsCancellationRequested,初始值为false
CancellationTokenSource cts = new CancellationTokenSource();
for(int i =0;i<1000;i++)
{
    Task.Run(()=>{
        try
        {
            //判断线程有没有被取消
            if(!cts.IsCancellationRequested)
                ....
           	if()
            {
                throw new Exception("异常发生") ;
            } 
        }
        catch(Exception ex)
        {
            //发出线程取消的信息
            cts.Cancel();
        }
     },cts.Token);
}
//其中cts.Token捕获到cts.Cancel的操作后会取消后续未开启的线程任务,这样就不用把所有线程都启动起来。
```

- 临时变量

```c#
//可能发生的问题是线程是非阻塞的，延迟启动，当线程执行时，i可能已经变成5了
//重点时非阻塞，极端情况想象一下，如果子线程启动很慢需要10s，那么for会很快循环5次创建5个子线程
//但是此时子线程才启动，导致此时子线程看到的i值已经变成5了
//k是闭包里面的变量，每次循环都有一个独立的k，相当于有一个i变量，5个k变量
for(int i=0;i<5;i++)
{ 
    int k = i;
    Task.Run(()=>{
       Console.WriteLine($"This is Thread_{i}_{k}"); 
    });
}
//结果可能为
//This is Thread_5_0
//This is Thread_5_1
//This is Thread_5_2
//This is Thread_5_3
//This is Thread_5_4
```

- 线程安全&lock

```c#
private int iNumSync = 0;
private int iNumAsync = 0;
private int iNumAsyncLock = 0;
//不能是null了，也不能是string，必须是个引用类型
private static readonly object Thread_Lock = new object();
//同步
for(int i =0;i<1000;i++)
{
    iNumSync++;
}
//异步
for(int i =0;i<1000;i++)
{
    //多线程会发生线程覆写的操作，导致值被丢失和修改
    Task.Run(()=>{iNiNumAsyncumSync++;})   
    Task.Run(()=>{
        lock(Thread_Lock)
        {
            iNumAsyncLock++;
        }
    })
}
//结果
iNumSync = 1000;
iNumAsync 不可预测[0,1000]; //非线程安全
iNumAsyncLock = 1000; //加锁
```

```c#
private void DoTest()
{
    //此时递归 lock this 不会发生死锁,因为这是同一线程，并没有创建新的线程执行
    lock(this) 
    {
        this.iDoTestNum++;
        if(DateTime.Now.Day<28 && this.iDoTestNum<10)
        {
            Console.WriteLine($"This is {this.iDoTestNum} {DateTime.Now.Day}");
            this.DoTest();
        }
        else
        {
        }
    }
}
private int iDoTestNum = 0;
```

```c#
Test test = new Test();
Task.Delay(1000).ContinueWith(t=>{
    //这里的this就是test本身，所以执行结果还是串行的
   lock(this)
   {
       ....
   }
});
test.DoTest();

```

```c#
//用线程安全集合
System.Collections.Concurrent.ConcurrentDictionary<T> 
//数据分拆，避免多线程操作同一个数据    

```







